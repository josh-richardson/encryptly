[Product name] aims to bring browser-based encrypted messaging to the mainstream. The behavior of the application is as follows:

User A wants to communicate securely with User B, however they are not able to meet up in order to exchange a symmetric encryption key in order to message each other securely online. [Product name] solves this problem by making use of transparent, easy-to-understand encryption technologies from within the browser, with the information necessary to decrypt communication never leaving the browser of each user. Provisions for one-to-one chats as well as many-to-many chats has been made. Users can express themselves with a wide variety of multimedia formats, with support for encrypted text, images and (?video?) embedded in the web application, as well as unicode emoticons.

The functionality of the web application:

When User A signs up, he/she is prompted to enter a username and password, as well as an "encryption password". In the next step of the signup process, a 4096-bit RSA key-pair is genereated on the client side using (cryptico or juliangruber/keypair). The private key of this key-pair is then encrypted using AES-256 (again on the clientside). Next, the username, password, public key, and encrypted private key are sent to the server over SSL and stored in a database. The user signup process is now complete, and the user can log in.

Users B and C sign up in the same fashion. The platform now has three users. Users A and B want to talk to each other securely using [Product name]. 

User A logs in to the website by first entering his/her username and password, and then his/her "encryption password". Only the username and password are sent over SSL to the server. If the username and password match with the database (the password being hashed using bcrypt), the server will send the encrypted version of the user's specific keypair over SSL to the user's browser. On the clientside, the user will attempt to decrypt the private key of the keypair using his/her "encryption password". If this process is successful, the user will sign a message sent by the server with his/her decrypted private key. This will be sent to the server, and if decrypted successfully with the user's public key, the user will be logged in.

Users B and C log in in the same fashion. 

User A knows User B's username, and initiates a chat with him/her by searching for his/her username. When the chat is created, a random string is generated on the clientside by User A. This string is then encrypted on the client side with User A's public key, and sent to the server for safe keeping. User A will now be able to decrypt this string in future sessions by requesting the encrypted version from the server and decrypting with his/her private key. User A also sends a request to the server, asking it for User B's public key. User A then encrypts the randomly generated string first with User B's public key, and then with User A's own private key. The encrypted version of the string is then sent to the server and stored in an object linked to User B's user profile.

Having logged in, User B receives a request to join a conversation with User A. User B receives the encryped version of the randomly generated string from User A, along with User A's public key. User B first decrypts the string with A's public key, and then with his/her own private key. This verifies that the random string was shared successfully without the server knowing of its contents. Once both users have the string, they use it as an encryption key. They encrypt each message using AES using the string as a key. They can thus both encrypt and decrypt messages between each other.